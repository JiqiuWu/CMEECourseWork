chaos_games <- function{
A = c(0,0)
B = c(3,4)
C = c(4,1)
X = c(0,0)
plot(0:4, 0:4, type = "n")
points(x = X[1], y = X[2], cex = 0.2)
pre_sample = list(A,B,C)
sam = sample(pre_sample, size = 1, replace = T)
i = 1
for (i in 1:1000){
x = sam
new_point = c((sam[1]+X[1]) / 2, (sam[2]+X[2]) / 2)
points(x = new_point[1], y = new_point[2], cex = 0.2)
X = new_point
i = i + 1
}
}
A = c(0,0)
B = c(3,4)
C = c(4,1)
X = c(0,0)
plot(0:4, 0:4, type = "n")
points(x = X[1], y = X[2], cex = 0.2)
pre_sample = list(A,B,C)
sam = sample(pre_sample, size = 1, replace = T)
sam
i = 1
for (i in 1:1000){
x = sam
new_point = c((x[1]+X[1]) / 2, (x[2]+X[2]) / 2)
points(x = new_point[1], y = new_point[2], cex = 0.2)
X = new_point
i = i + 1
}
x = sam
x
new_point = c((x[1][1]+X[1]) / 2, (x[2][1]+X[2]) / 2)
X[1]
x[1]
x[1][1]
type(x)
class(x)
x[][]
x[[1]]
x[[[1]]]
x[1]
class(x[1][1])
?lines
turtle <- function(start_position, direction, length){
start_point(x = start_position[1], y = start_position[20], cex = 0.2 )
end_point(x = start_position[1] + length * cos(direction), y = start_position[2] + length * sin(direction))
lines(x = start_point, y = end_point)
}
turtle(start_position = c(2,2), direction = pi, length = 1)
turtle <- function(start_position, direction, length){
start_point(x = start_position[1], y = start_position[2], cex = 0.2 )
end_point(x = start_position[1] + length * cos(direction), y = start_position[2] + length * sin(direction))
lines(x = start_point, y = end_point)
}
turtle(start_position = c(2,2), direction = pi, length = 1)
turtle <- function(start_position, direction, length){
start_point = c(x = start_position[1], y = start_position[2] )
end_point = c((x = start_position[1] + length * cos(direction), y = start_position[2] + length * sin(direction)))
lines(x = start_point, y = end_point)
}
turtle <- function(start_position, direction, length){
start_point = c(start_position[1], start_position[2])
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
lines(x = start_point, y = end_point)
}
plot(0:4, 0:4, type = "n")
plot(0:4, 0:4, type = "n")
turtle <- function(start_position, direction, length){
start_point = c(start_position[1], start_position[2])
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
lines(x = start_point, y = end_point)
}
turtle(c(2,2), pi, 1)
turtle(c(2,2), (1/3)pi, 1)
turtle(c(2,2), 1/3pi, 1)
turtle(c(2,2), 0.1pi, 1)
turtle(c(2,2), pi, 1)
turtle(c(2,2), pi, 2)
turtle(c(2,2), pi/3, 2)
elbow <- function(start_position,direction, length){
start_point = c(start_position[1], start_position[2])
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
second_point = c(end_point[1] + 0/95 * length * cos(pi/4), end_point[2] + 0.95 * length * sin(pi/4))
lines(start_point, end_point, second_point)
}
plot(0:4, 0:4, type = "n")
elbow <- function(start_position,direction, length){
start_point = c(start_position[1], start_position[2])
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
second_point = c(end_point[1] + 0/95 * length * cos(pi/4), end_point[2] + 0.95 * length * sin(pi/4))
lines(start_point, end_point, second_point)
}
turtle(c(2,2), pi/3, 2)
elbow(c(2,2), pi/3, 2)
elbow <- function(start_position,direction, length){
start_point = c(start_position[1], start_position[2])
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
second_point = c(end_point[1] + 0/95 * length * cos(pi/4), end_point[2] + 0.95 * length * sin(pi/4))
lines(start_point, end_point)
lines(end_point, second_point)
}
elbow <- function(start_position,direction, length){
start_point = c(start_position[1], start_position[2])
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
second_point = c(end_point[1] + 0/95 * length * cos(pi/4), end_point[2] + 0.95 * length * sin(pi/4))
lines(start_point, end_point)
lines(end_point, second_point)
}
elbow(c(2,2), pi/3, 2)
graphics.off()
elbow <- function(start_position,direction, length){
start_point = c(start_position[1], start_position[2])
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
second_point = c(end_point[1] + 0/95 * length * cos(pi/4), end_point[2] + 0.95 * length * sin(pi/4))
lines(start_point, end_point)
lines(end_point, second_point)
}
elbow(c(2,2), pi/3, 2)
graphics.off()
plot(0:4, 0:4, type = "n")
elbow <- function(start_position,direction, length){
start_point = c(start_position[1], start_position[2])
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
second_point = c(end_point[1] + 0/95 * length * cos(pi/4), end_point[2] + 0.95 * length * sin(pi/4))
lines(start_point, end_point)
lines(end_point, second_point)
}
elbow(c(2,2), pi/3, 2)
elbow <- function(start_position,direction, length){
start_point = c(start_position[1], start_position[2])
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
second_point = c(end_point[1] + 0/95 * length * cos(pi/4), end_point[2] + 0.95 * length * sin(pi/4))
lines(x = start_point, y = end_point)
lines(x = end_point, y = second_point)
}
elbow(c(2,2), pi/3, 2)
graphics.off()
plot(0:4, 0:4, type = "n")
elbow <- function(start_position,direction, length){
turtle(start_position,direction, length)
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
turtle(end_point, pi/4, 0.95*length)
}
elbow(c(2,2), pi, 2)
elbow = function(start, direction, len){
direction = direction * (pi/180)
a = turtle(start, direction, len)
turtle(a, direction - 45, (0.95*(len)))
}
turtle = function(start, direction, len, col = 1){
direction = direction * (pi/180)
points(x = start[1], y= start[2], cex = 0.1, col = col)
new_xy = c(((len * (cos(direction)))+start[1]), ((len * sin(direction))+start[2]))
x = c(start[1], new_xy[1])
y = c(start[2], new_xy[2])
lines(x=x , y = y , col = col)
return(new_xy)
}
elbow = function(start, direction, len){
direction = direction * (pi/180)
a = turtle(start, direction, len)
turtle(a, direction - 45, (0.95*(len)))
}
eblow(c(2,2), pi, 2)
elbow(c(2,2), pi, 2)
lst <- list()
for (i in 1:2000){
if (i %% 20 == 0){
lst[[i]] = octaves(neutral_time_series_speciation(initialise_max(100),0.1,i))
i = i + 1
}
}
lst
class(lst)
num = as.numeric(lst)
num = as.numeric(lst[[]])
lst[[1000]]
lst[1000]
for (i in 201:2000)
if (i %% 20 == 0){
lst_1[[i]] == lst[[1]]
}
lst_1 <-list()
for (i in 201:2000)
if (i %% 20 == 0){
lst_1[[i]] == lst[[1]]
}
lst_1 <-list()
for (i in 201:2000)
if (i %% 20 == 0){
lst_1[[i]] == lst[[1]]
}
lst_1 <-list()
for (i in 201:2000)
if (i %% 20 == 0){
lst_1[[i]] == lst[[i]]
}
lst <- list()
for (i in 1:2000){
for (n in 1:100){
if (i %% 20 == 0){
lst[[n]] = octaves(neutral_time_series_speciation(initialise_max(100),0.1,i))
i = i + 1
}
}
# return(lst)
}
lst
length(lst)
lst <- list()
for (i in 1:2000){
for (n in 1:100){
if (i %% 20 == 0){
lst[[n]] = octaves(neutral_time_series_speciation(initialise_max(100),0.1,i))
i = i + 1
n = n + 1
}
}
# return(lst)
}
lst
length(lst)
lst <- list()
for (i in 1:2000){
if (i %% 20 == 0){
lst[[n]] = octaves(neutral_time_series_speciation(initialise_max(100),0.1,i))
i = i + 1
}
# return(lst)
}
lst
lst <- list()
for (i in 1:2000){
if (i %% 20 == 0){
lst = addend(octaves(neutral_time_series_speciation(initialise_max(100),0.1,i)))
i = i + 1
}
# return(lst)
} # technically, there should't be 999,998...but there are
??add.scope
lst <- list()
for (i in 1:2000){
if (i %% 20 == 0){
lst = append(octaves(neutral_time_series_speciation(initialise_max(100),0.1,i)))
i = i + 1
}
# return(lst)
}
?append
lst <- list()
for (i in 1:2000){
if (i %% 20 == 0){
lst = append(lst, octaves(neutral_time_series_speciation(initialise_max(100),0.1,i)))
i = i + 1
}
# return(lst)
}
lst
length(lst)
for (i in 1:2000){
if (i %% 20 == 0){
lst = append(lst, octaves(neutral_time_series_speciation(initialise_max(100),0.1,i)))
}
# return(lst)
}
lst
for (i in 1:2000){
if (i %% 20 == 0){
lst = append(lst, c(octaves(neutral_time_series_speciation(initialise_max(100),0.1,i))))
}
# return(lst)
}
lst <- list()
for (i in 1:2000){
if (i %% 20 == 0){
lst[[i]] = apoctaves(neutral_time_series_speciation(initialise_max(100),0.1,i)))
}
# return(lst)
}
lst <- list()
for (i in 1:2000){
if (i %% 20 == 0){
lst[[i]] = apoctaves(neutral_time_series_speciation(initialise_max(100),0.1,i)))
}
# return(lst)
}
lst <- list()
for (i in 1:2000){
if (i %% 20 == 0){
lst[[i]] = apoctaves(neutral_time_series_speciation(initialise_max(100),0.1,i)))
}
result = x + y
lst <- list()
for (i in 1:2000){
if (i %% 20 == 0){
lst[[i]] = apoctaves(neutral_time_series_speciation(initialise_max(100),0.1,i)))
}
# return(lst)
} # technically, there should't be 999,998...but there are
lst <- list()
for (i in 1:2000){
if (i %% 20 == 0){
lst[[i]] = octaves(neutral_time_series_speciation(initialise_max(100),0.1,i))
i = i + 1
}
# return(lst)
} # tech
list_1 = ra.rm(lst)
list_1 = rm.ra(lst)
lst
list = list[is.ra = F]
list = lst[is.ra =
list = lst[is.ra = F]
list = lst[is.ra = T]
length(lst[999])
lst[999]
lst[999] > 0
lst[[999]]>0
logical(0)
T
T == logical(0)
lst
list_1 = lst[-which(sapply(lst,is.null))]
list_1
sum_list = c()
sum_list = sum_vect(sum_list,list_1)
lst <- list()
for (i in 1:2000){
if (i %% 20 == 0){
lst[[i]] = octaves(neutral_time_series_speciation(initialise_max(100),0.1,i))
i = i + 1
}
all_octaves = lst[-which(sapply(lst,is.null))]
}
lst <- list()
for (i in 1:2000){
if (i %% 20 == 0){
lst[[i]] = octaves(neutral_time_series_speciation(initialise_max(100),0.1,i))
i = i + 1
}
}
all_octaves = lst[-which(sapply(lst,is.null))]
class(all_octaves)
d = unlist(all_octaves)
d
class(all_octaves[99])
class(all_octaves[[99])
class(all_octaves[[99]])
length(all_octaves)
all_octaves[1]
c = sum_vect(all_octaves[1],all_octaves[2])
d = sum_vect(c(1,3),c(1,0,5,2))
d
class(c(1,3))
c = sum_vect(all_octaves[[1]],all_octaves[[2]])
c
aver = all_octaves[[1]]
for (i in 2:100){
aver = c(aver, all_octaves[[i]])
}
aver
aver = all_octaves[[1]]
for (i in 2:100){
aver = sum_vect(aver, all_octaves[[i]])
}
aver
?which
aver/100
e = aver/100
3
e
barplot(e)
lst <- list()
for (i in 1:2000){
if (i %% 20 == 0){
lst[[i]] = octaves(neutral_time_series_speciation(initialise_max(100),0.1,i))
i = i + 1
}
all_octaves = lst[-which(sapply(lst,is.null))]
summa = all_octaves[[1]]
for (i in 2:100){
summa = sum_vect(summa, all_octaves[[i]])
average = summa/100
barplot(average)
# return(lst)
}
}
list_1 = lst[-which(sapply(lst,is.null))]
for (i in 1:2000){
if (i %% 20 == 0){
lst[[i]] = octaves(neutral_time_series_speciation(initialise_max(100),0.1,i))
i = i + 1
}
}
ll_octaves = lst[-which(sapply(lst,is.null))]
all_octaves = lst[-which(sapply(lst,is.null))]
summa = all_octaves[[1]]
for (i in 2:100){
summa = sum_vect(summa, all_octaves[[i]])
average = summa/100
barplot(average)
# return(lst)
}
neutral_time_series_speciation(community = c(1,2,3,4,5), v = 0.1, duration = 100)
f = neutral_time_series_speciation(community = c(1,2,3,4,5), v = 0.1, duration = 100)
lengt]
length(f)
elbow <- function(start_position,direction, length){
turtle(start_position,direction, length)
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
turtle(end_point, pi/4, 0.95*length)
} # the figure is wrong
turtle <- function(start_position, direction, length){
start_point = c(start_position[1], start_position[2])
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
lines(x = start_point, y = end_point)
}
chaos_games <- function{
A = c(0,0)
B = c(3,4)
C = c(4,1)
X = c(0,0)
plot(0:4, 0:4, type = "n")
points(x = X[1], y = X[2], cex = 0.2)
pre_sample = list(A,B,C)
sam = sample(pre_sample, size = 1, replace = T)
i = 1
for (i in 1:1000){
x = sam
new_point = c((x[1][1]+X[1]) / 2, (x[2][1]+X[2]) / 2) # need to extract the exact element
points(x = new_point[1], y = new_point[2], cex = 0.1)
X = new_point
i = i + 1
}
}
#23 turtle
turtle <- function(start_position, direction, length){
start_point = c(start_position[1], start_position[2])
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
lines(x = start_point, y = end_point)
}
turtle <- function(start_position, direction, length){
start_point = c(start_position[1], start_position[2])
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
lines(x = start_point, y = end_point)
}
turtle(start_position = c(2,3), direction = pi/3, length = 2)
turtle(start_position = c(2,3), direction = pi/3, length = 1)
turtle(start_position = c(2,3), direction = pi/3, length = 1)
elbow <- function(start_position,direction, length){
turtle(start_position,direction, length)
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
turtle(end_point, pi/4, 0.95*length)
}
elbow(start_position = c(2,3), direction = pi/3, length = 1)
elbow <- function(start_position,direction, length){
turtle(start_position,direction, length)
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
turtle(end_point, direction - pi/4, 0.95*length)
}
elbow(start_position = c(2,3), direction = pi/3, length = 1)
end_point
elbow <- function(start_position,direction, length){
turtle(start_position,direction, length)
#end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
turtle(end_point, direction - pi/4, 0.95*length)
} # the figure is wrong
elbow(start_position = c(2,3), direction = pi/3, length = 1)
elbow <- function(start_position,direction, length){
turtle(start_position,direction, length)
start_position = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
turtle(start_position, direction - pi/4, 0.95*length)
} # the figure is wrong
elbow(start_position = c(2,3), direction = pi/3, length = 1)
graphics.off()
chaos_games <- function{
A = c(0,0)
B = c(3,4)
C = c(4,1)
X = c(0,0)
plot(0:4, 0:4, type = "n")
points(x = X[1], y = X[2], cex = 0.2)
pre_sample = list(A,B,C)
sam = sample(pre_sample, size = 1, replace = T)
i = 1
for (i in 1:1000){
x = sam
new_point = c((x[1][1]+X[1]) / 2, (x[2][1]+X[2]) / 2) # need to extract the exact element
points(x = new_point[1], y = new_point[2], cex = 0.1)
X = new_point
i = i + 1
}
}
#23 turtle
turtle <- function(start_position, direction, length){
start_point = c(start_position[1], start_position[2])
end_point = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
lines(x = start_point, y = end_point)
}
elbow <- function(start_position,direction, length){
turtle(start_position,direction, length)
start_position = c(start_position[1] + length * cos(direction), start_position[2] + length * sin(direction))
turtle(start_position, direction - pi/4, 0.95*length)
} # the figure is wrong
elbow(start_position = c(2,3), direction = pi/3, length = 1)
rm(ls())
